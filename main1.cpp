#include <string>
#include <vector>
#include <numeric>  // for std::iota
#include <iostream>
#include <fstream>

using namespace std; 
// Normalize characters (a-z = 0-25, A-Z = 0-25, 0-9 = 26-35, others = ASCII value)
int returnVal(char x) {
    if (x >= 'a' && x <= 'z') return x - 'a';
    if (x >= 'A' && x <= 'Z') return x - 'A';
    if (x >= '0' && x <= '9') return x - '0' + 26;
    return static_cast<int>(x);  // fallback for symbols
}

std::string hashing(const std::string& s) {
    const int seedSize = 64;
    std::vector<unsigned int> seed(seedSize, 0);
    
    // Initialize seed with non-zero values
    for (int i = 0; i < seedSize; ++i) {
        seed[i] = i * 2654435761 % 4294967291;  // Use a large prime
    }

    unsigned int hash = 2166136261u;  // FNV offset basis

    // Main mixing loop â€” every char affects all seed positions over time
    for (size_t i = 0; i < s.length(); ++i) {
        unsigned int val = returnVal(s[i]);
        hash ^= val;
        hash *= 16777619;  // FNV prime

        // Mix hash into the seed vector using variable stride
        int stride = (val % seedSize) + 1;
        for (int j = 0; j < seedSize; j += stride) {
            seed[j] ^= (hash >> (j % 16)) + val + i;
            seed[j] = (seed[j] << 5 | seed[j] >> 27) ^ (hash + j * 31);
            seed[j] %= 256;
        }
    }

    // Final compression pass to reduce correlation
    for (int i = 0; i < seedSize; ++i) {
        seed[i] ^= seed[(i + 1) % seedSize];
        seed[i] = (seed[i] * 31 + i) % 256;
    }

    // Map to alphanumeric output
    const char* alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    std::string result;
    for (int i = 0; i < seedSize; ++i) {
        result += alphabet[seed[i] % 62];
    }

    return result;
}

void read_line(const std::string& filename) {
    std::ifstream file("data/"+filename);
    std::ofstream out ("clean_output/"+filename);

    if (!file) {
        throw std::runtime_error("Unable to open file: " + filename);
    }

    std::string line;
    while (std::getline(file, line)) {
        //cout << line << " -> " << hashing(line) << endl;
        //out << line << " -> " << hashing(line) << endl;
        out << hashing(line) << endl;
    }
}

int main () {
    read_line("1000_seq.txt");
    cout << hashing("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    cout << endl;
    cout << hashing("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
}